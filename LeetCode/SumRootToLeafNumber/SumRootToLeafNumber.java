/** * Definition for binary tree * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */public class Solution {    public int sumNumbers(TreeNode root) {        // Start typing your Java solution below        // DO NOT write main() function        ArrayList<Integer> s = helper(root);        int res = 0;        for(int i=0; i<s.size(); i++)        {            res += s.get(i);        }        return res;    }        private ArrayList<Integer> helper(TreeNode root)    {        // This will save all the Integer represents by the path        ArrayList<Integer> paths = new ArrayList<Integer>();        //we will do iterative post order visit        ArrayList<TreeNode> path = new ArrayList<TreeNode>();                if(root == null)         return paths;                 TreeNode curr = root;        TreeNode prev = null;        moveToLeftB(root, prev, path);                while(path.size() > 0)        {            TreeNode top = path.get(path.size()-1);                        if(top.left == null && top.right == null) //reach a leaf node            {                int res = convertListToInt(path);                paths.add(res);                prev = top;                path.remove(path.size()-1); //pop of the stack and update last one            }else if(prev == top.right)             //we reach this node from right child, ready to process this node            // we know this is not a leaf node            {                prev = top;                path.remove(path.size() -1 );            }else            {                // here we will add the right child when it has a right child                // this subsection is tricy, we need distinguish the case to add or remove                if(top.right!=null)                {                    prev = top;                    top = top.right;                    moveToLeftB(top, prev, path);                }else{                    prev = top;                    path.remove(path.size()-1); //pop of the stack and update last one                }            }        }        return paths;    }        private void moveToLeftB(TreeNode root, TreeNode prev,ArrayList<TreeNode> p)    {        while(root!=null)        {            p.add(root);            prev = root;            root = root.left;        }          }    private  int convertListToInt(ArrayList<TreeNode> p)    {        int res = 0;        for(int i=0; i<p.size(); i++)        {            res =res*10 + p.get(i).val;                    }        return res;    }}